---
id: apply
title: Apply()
sidebar_label: Apply()
---

#### NOTE: 
  - `Apply()` is a query run against our `float64` and `int64` columns types. For more information on using these data types in FeatureBase, visit [ingest](TODO) documentation and the following HTTP API endpoints (TODO).
  - `Apply()` is currently limited to the community version only. It's is not applicable to cloud at this time.

The `Apply()` query uses the map / reduce framework to compute on float64 and int64 data types. In FeatureBase, data is sharded by records. Meaning, a single table is split into multiple shards or segements by records. A single shard contains the data for some subset of records in that index. For this reason, Apply() takes two arguments (`MAP_FUNCTION` and `REDUCE_FUNCTION`) which are written in Ivy. Ivy is an APL-like language. The source code for ivy can be found [here](https://github.com/robpike/ivy). If you haven't seen ivy before, [this demo](https://github.com/robpike/ivy/blob/master/demo/demo.ivy) is a good place to start to get familiar with it. Read the mandatory arguments section below for more on the map and reduce phases.

## Call Definition

```pql
Apply(ROW_CALL, MAP_FUNCTION, REDUCE_FUNCTION)
```

#### Mandatory Arguments
- `ROW_CALL` : the output of any [row call](/pql-guide/pql-introduction#Crow-calls){:target="_blank"} (set of record IDs / keys). Only data for records returned here will make it to the `MAP_FUNCTION`. Filter records as much as possible here to improve performance.
- `MAP_FUNCTION` : ivy function to be performed at the shard level. This function will run records from each shard (think subset of records) that are returned by `ROW_CALL`. In most cases, it's best to perform as much work at this phase as possible. The output from each shard is passed to the reduce phase. 
- `REDUCE_FUNCTION` : ivy query to be performed on the aggregation or concatenation of the output of the `MAP_FUNCTION`. The input of the reduce phase is the output of the map phase. You're guarenteed to get


#### Optional Arguments
#### Returns
- A list of float64 or int64 values
    
## Examples

### Data:

```
Index: weather (non keyed)

  _id  | events (keyed set) |  min_temp (float64) | max_temp (float64) | rainfall (float64)
-------+--------------------+---------------------+--------------------+--------------------
   0   |    cloudy          |        8.0          |      24.3          |        0.0
   1   |    rain,cloudy     |       14.0          |      26.9          |        3.6
   2   |    sunny           |       13.7          |      23.4          |        0.0
   3   |    cloudy          |       13.3          |      15.5          |        2.9
```
-----------------------------------------------------------------------
### Example 1
Return all the data ingested as float64. Let's assume all the data is in a single shard.

#### Query
```
[weather]Apply(
  All(),
  "min_temp,max_temp,rainfall",
  "_"
)
```
#### Tabular Response
#### HTTP Response

```json
{
  "results": [
    {
      "F": {
        "float": [
          0
          3.6,
          0
          2.9,
          24.3,
          26.9,
          23.4,
          15.5,
          8,
          14,
          13.7,
          13.3
        ]
      }
    }
  ]
}
```
#### Explanation:
All() returns every record in the index. Here the map function just says, return the data for these three columns unprocessed. Similarly, the reduce function says, pass all the data from the map phase through unprocessed. It's important to note here that the data is coming back conceptually as lists of columns rather than lists of records.


### Example 2
Return all the data ingested as float64. Let's assume records 0 & 1 are on the same shard and record 2 & 3 are on on the same shard.

#### Query
```
[weather]Apply(
  All(),
  "min_temp,max_temp,rainfall",
  "_"
)
```
#### Tabular Response
#### HTTP Response
```json
{
  "results": [
    {
      "F": {
        "float": [
          0,
          3.6,
          24.3,
          26.9,
          8,
          14,
          0,
          2.9,
          23.4,
          15.5,
          13.7,
          13.3
        ]
      }
    }
  ]
}
```
#### Explanation:
All() returns every record in the index. Here the map function just says, return the data for these three columns unprocessed. Similarly, the reduce function says, pass all the data from the map phase through unprocessed. Again, the data is coming back conceptually as lists of columns rather than lists of records. However, you can see that we get a list **per** shard. We said above, the records were split into two shrads. So we get two seperate list for the min_temp, max_temp, and rainfall columns.

### Example 3
Return all the data ingested as float64. This time we'll assume at least two record are on the same shard. We want to return list of records to the reduce phase this time.

#### Query
```
[weather]Apply(
  All(),
  "x = min_temp,max_temp,rainfall # select these three columns
   r = 3 4 rho x # reshape list of columns to 3 x 4 array   
   t = transp r # transpose array
   (rho x) rho t # flatten the results to get list of records",
  "_"
)
```
#### Tabular Response
#### HTTP Response
```json
{
  "results": [
    {
      "F": {
        "float": [
          2.9,
          15.5,
          13.3,
          0,
          24.3,
          8,
          0,
          23.4,
          13.7,
          3.6,
          26.9,
          14
        ]
      }
    }
  ]
}
```
#### Explanation:
Again, All() returns every record in the index. Here the map phase is turning lists of columns to list of records. You can see from the comments what's going on.

You'll notice the first three elements are the min_temp, max_temp, and rainfail for record 3. The second three values are the min_temp, max_temp, and rainfall for record 0. And so on.

It's important to note that we cannot make assumptions on the order of these 3-tuples. Meaning, record 0 could be the first tuple but it might not be. However, we can assume that the first element in each tuple is associated with rainfall, the second is associated with max_temp, and so on. 

---

#### Example 4

Compupte the euclidean distance between record 0 and record 1.

#### Query

```
Apply(
  ConstRow(columns=["0","1"]),
  "x = min_temp,max_temp,rainfall
   t = transp 3 2 rho x
   (rho x) rho t",
  "x = _
   y = 2 3 rho x # reshape data to 2 x 3 array
   sqrt +/ (y[1] - y[2]) ** 2 # square root the sum of squares"
)
```

#### Tabular Response
#### HTTP Response
```json
{'results': [{'F': {'float': [7.464583042608608]}}]}
```

#### Explanation
The filter here limits the records to 0 and 1. Similar to the example above, the map phase turns list of columns to list of records. The reduce phase reshapes the data and the computes the euclidean distance between the two vectors in ivy!

